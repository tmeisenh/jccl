/* $Id$ */
/*
 * Copyright (c) 2005 - 2007 Travis B. Meisenheimer
 * All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

package com.indexoutofbounds.mainframe.legacy.converter.impl;

import java.text.DecimalFormat;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import com.indexoutofbounds.mainframe.converter.MainFrameGlobals;
import com.indexoutofbounds.mainframe.exception.NumberSizeException;
import com.indexoutofbounds.mainframe.exception.Sock7Exception;

/**
 * <p>This class contains converters from fixed decimal byte arrays of packed
 * decimal (COMP-3) and un/signed numbers (NUMERIC) into <code>double</code> 
 * or <code>long</code> as well as converters from <code>long</code>, and 
 * <code>double</code> to packed decimal (COMP-3) and un/signed numbers 
 * (NUMERIC) (byte[]).</p>
 * 
 * <p>Input to convert a COMP-3 or NUMERIC should be in a <code>byte[]</code>, 
 * and you must use a reader which reads in byte[] and not a char[] or int[].</p>
 * 
 * <p>This class has been nearly fully refactored/re-engineered from the original to include
 * support for much larger numbers (both as native <code>double</code> types and as a 
 * <code>String</code>, QuickConversion ability for REALLY large numbers, and making the code
 * legible (commenting, cleaning up useless operations, cleaning up useless parameters).</p>
 * 
 * <p>Notes: If you require conversion of un/signed NUMERIC values or COMP-3 values to return
 * basically an unmodified String representation of the bytes, then use the 
 * <code>convertCOMP3WithHighPrecision</code> and 
 * <code>convertNumericValueWithHighPrecision</code> methods.  These internally use a StringBuffer
 * for storage and everything is just appened as-is.  Leading zeros will be there.</p>
 * 
 * <p>If you need to convert a Java numeric primitive of large precision, you must either modify
 * <code>formatDoubleValue</code> to remove the if-condition to force all values to be run
 * through the DecimalFormat'er.  This will slow things down quite a bit but the results will
 * be accurate.</p>
 * 
 * <p>"You know Cobol is so old, a lot of people would get a listening of the Assembly code
 * generated by the compiler just to get a better picture of what sort of liberties
 * the compiler was taking behind the scenes.  That's how primitive these things were 
 * in the late 60s and early 70s." -- COBOL guru</p>
 * 
 * <p>Examples of how COBOL Stores data:<ul>
 * <li>COBOL format: data : byte layout: Description</li>
 * <li>S9(3) : +999 : F9 F9 C9 : Signed Numeric</li>
 * <li>9(3) : +999 : F9 F9 F9 : Unsigned Numeric</li>
 * <li>S9(3)v99 : +999.99 : F9 F9 F9 F9 C9 : Signed Numeric decimal with two places after decimal</li>
 * <li>S9(3) COMP-3 : +987 : 98 7C: Signed Numeric COMP-3</li>
 * </ul>
 * 
 * @author The Apache Derby Group http://db.apache.org/derby/
 * @author <a href="mailto:travis@indexoutofbounds.com">Travis Meisenheimer</a>
 * @deprecated - This class has been broken up into four smaller classes.  See 
 * AlphanumericConversionUtils, BaseCobolUtils, Comp3ConversionUtils, and NumericConversionUtils.
 * 
 * @link http://db.apache.org/derby
 */

public class COBOLConversionUtil {

	/**
	 * Anything larger than this is not allowed to be translated because anything
	 * much larger than this and we won't know if the incoming byte[] contains a value
	 * that a double can't hold.  We have String returning functions for REALLY big
	 * numbers.
	 * 
	 * This value is equivalent to Math.pow(2, 1008) and should be more than plenty
	 * big enough for anything on a MainFrame.
	 */
	public final static double DOUBLE_MAX_TRANSLATION_VALUE = 2.7430620343968443E303;

	/**
	 * Anything smaller than this is not allowed to be translated because anything
	 * much smaller than this and we won't know if the incoming byte[] contains a value
	 * that a double can't hold.  We have String returning functions for REALLY smaller
	 * numbers.
	 * 
	 * This value is equivalent to Math.pow(2, 1008) * -1 and should be more than plenty
	 * big enough for anything on a MainFrame.
	 */
	public final static double DOUBLE_MIN_TRANSLATION_VALUE = DOUBLE_MAX_TRANSLATION_VALUE * -1;

	/**
	 * A precision higher than this would cause the resulting translated value to be higher
	 * than DOUBLE_MAX_TRANSLATION_VALUE.  This also limits the allowed byte[] size to be
	 * less than 155; however we should never get an odd value so 154 is good enough.
	 * 
	 * If we run into problems with this being too low then the 
	 * <code>DOUBLE_MAX_TRANSLATION_VALUE</code> would need to be increased by factors of
	 * two.
	 */
	public final static int DOUBLE_PRECISION_LIMIT = 308;

	/**
	 * How the above numbers were discovered: The max value for a Java double is 2^1024
	 * which in packed bytes is 310 bytes long.  This is too big so we decrement by a full 
	 * byte and we then get 2^1016 which is 309 bytes -- but all packed bytes must be 
	 * evenly divisible by 2 so we then decrement again and get 2^1008 which is 308 bytes 
	 * and a safe value.
	 */

	/**
	 * This is the max value that a packed (COMP-3) byte can hold.  This is equivalent
	 * to the byte containing two nines, 1001 1001.
	 */
	public final static int PACKED_BYTE_MAX_VALUE = 153;

	/**
	 * This is the max value that a numeric byte can hold.  This is equivalent
	 * to the byte containing an F and one nine, 1111 1001.
	 */

	public final static int NUMERIC_BYTE_MAX_VALUE = 159;

	/**
	 * This class does make sure that data is within the above MAX_VALUEs but those values
	 * are large enough for almost anything.
	 */

	public static final char SIGN_POS = 'C'; // 0xC
	public static final char SIGN_NEG = 'D'; // 0xD
	public static final char SIGN_UNSIGNED = 'F'; // 0xF

	public static final byte HEX_NEG = 0x0D;

	/**
	 * Low nybble mask value, 0000 1111
	 */
	public static final byte LOW_NYBBLE_MASK = 0x0F;

	/**
	 * High nybble mask value, 1111 0000
	 */
	public static final int HIGH_NYBBLE_MASK = 0xF0;

	/**
	 * Formatter to strip out SI Notation
	 */
	private final static DecimalFormat decimalformat = new DecimalFormat(MainFrameGlobals.DOUBLE_FORMAT);

	/**
	 * Logger this class uses.
	 */
	private static Logger log = Logger.getLogger(COBOLConversionUtil.class);

	/**
	 * Don't allow this class to be instantiated.
	 */
	public COBOLConversionUtil() {
	}

	/**
	 * Build a Java <code>String</code> from a fixed point decimal byte
	 * COMP-3 representation.  The precision is calculated internally based
	 * on the length of the byte[].
	 * 
	 * This method is the most efficient way in dealing with large values and
	 * large precision values. This method also returns a String representation
	 * of the data EXACTLY as it appeared in the byte[] except for the inserting
	 * of a period where a decimal point was required.
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return String of the converted packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final String convertCOMP3ToString(byte[] buffer, int scale) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();

		if (isNegativeLowNybbleSignBit(buffer[buffer.length - 1])) {
			sb.append('-');
		}

		sb.append(packedNybblesToString(buffer));

		// set the decimal at the right place
		if (scale > 0) {
			//TODO check this here?
			sb.insert((sb.length() - scale), '.');
		} else {
			for (int i = 0; i < scale; i++)
				sb.append("0");
		}

		return sb.toString();
	}

	/**
	 * Build a Java <code>double</code> from a fixed point decimal byte
	 * representation.  The precision is calculated internally based
	 * on the length of the byte[].
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return double amount of the packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final double convertCOMP3ToDouble(byte[] buffer, int scale) throws Sock7Exception {

		// check for sign.
		int signum = digOutSignMultiplierLowNybble(buffer[buffer.length - 1]);

		if (determinePrecision(buffer.length) > DOUBLE_PRECISION_LIMIT) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		return signum * packedNybblesToDouble(buffer) / Math.pow(10, scale);
	}

	/**
	 * Build a Java <code>long</code> from a fixed point decimal byte
	 * representation.  The precision is calculated internally based
	 * on the length of the byte[].  This implies that the returned value
	 * will be up to 18 digits WITHOUT a decimal place.
	 * 
	 * @deprecated use packedBytesIntoDouble instead
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return long amount of the packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final long convertCOMP3ToLong(byte[] buffer, int scale) throws Sock7Exception {

		if (determinePrecision(buffer.length) > DOUBLE_PRECISION_LIMIT) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		double d = (digOutSignMultiplierLowNybble(buffer[buffer.length - 1]) * packedNybblesToDouble(buffer));

		if (Long.MAX_VALUE > d && d < Long.MAX_VALUE) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}
		
		return Long.parseLong(decimalformat.format(d / Math.pow(10, scale)));
	}

	/**
	 * Build a Java <code>String</code> from a fixed point numeric byte
	 * representation.  The precision is calculated internally based
	 * on the length of the byte[].
	 * 
	 * This method is the most efficient way in dealing with large values and
	 * large precision values. This method also returns a String representation
	 * of the data EXACTLY as it appeared in the byte[] except for the inserting
	 * of a period where a decimal point was required.
	 *
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return String of the converted packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final String convertNumericToString(byte[] buffer, int scale) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();
		
		// This throws an exception if the sign bit isn't valid.		
		if (isNegativeHighNybbleSignBit(buffer[buffer.length - 1])) {
			sb.append('-');
		}

		sb.append(numericNybblesToString(buffer));
		// set the decimal at the right place
		if (scale > 0) {
			sb.insert((sb.length() - scale), '.');
		} else {
			for (int i = 0; i < scale; i++)
				sb.append("0");
		}

		return sb.toString();
	}

	/**
	 * Build a Java <code>double</code> from a signed numeric (NOT PACKED) decimal byte
	 * representation.  The precision is calculated internally based
	 * on the length of the byte[].
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return double amount of the packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final double convertNumericToDouble(byte[] buffer, int scale) throws Sock7Exception {

		if (buffer.length > DOUBLE_PRECISION_LIMIT) {

			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		// check for sign.
		int signum = digOutSignMultiplierHighNybble(buffer[buffer.length - 1]);

		double value = numericNybblesToDouble(buffer);
		return signum * value / Math.pow(10, scale);
	}

	/**
	 * Build a Java <code>long</code> from a signed numeric (NOT PACKED) decimal byte
	 * representation.  The precision is calculated internally based
	 * on the length of the byte[].
	 *  
	 * @deprecated use numericBytesIntoDouble instead
	 * @param buffer - the byte[] containing the packed decimal
	 * @param scale - the number of digits after the implied decimal
	 * @return long amount of the packed data
	 * @throws Sock7Exception if the specified representation is not recognized.
	 */
	public static final long convertNumericToLong(byte[] buffer, int scale) throws Sock7Exception {

		if (buffer.length > DOUBLE_PRECISION_LIMIT) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		// check for sign.	
		int signum = digOutSignMultiplierHighNybble(buffer[buffer.length - 1]);

		double d = numericNybblesToDouble(buffer);

		if (Long.MAX_VALUE > d && d < Long.MAX_VALUE) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}
		// The double shouldn't contain any precision values...
		return (long) (signum * d / Math.pow(10, scale));
	}

	/**
	 * Converts an int into a packed decimal.  Typically in COBOL a packed number
	 * is written like S9(3) which means the largest number is 999 but the number
	 * can range like 099 and 009 -- note the zeros for padding.  This method handles
	 * all the oddities of COBOL land with regard to packing the number.
	 * 
	 * Note: scale can be less than zero. This means that the assumed decimal point 
	 * is -scale digits to the right of the LSD. For example, if the data in the 
	 * input file is 123 and the scale is –2, then the value thus represented is 12300. 
	 * 
	 * @param val the value to pack 
	 * @param byteLength the expected output byte[] length
	 * @param scale the number of digits after the implied decimal
	 * @return byte[] reprensentation of a packed decimal
	 * @throws Sock7Exception
	 */
	public static byte[] convertIntToCOMP3(int val, int byteLength, int scale, boolean isSigned) throws Sock7Exception {

		if (!isWithinTolerance(val)) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		char sign;
		if (!isSigned) {
			sign = SIGN_UNSIGNED;
		} else {
			sign = (val < 0) ? SIGN_NEG : SIGN_POS;
		}

		return packDataIntoBytes(normalizeJavaDataIntoCOMP3ByteString(formatIntValue(val), byteLength, scale, sign));
	}

	/**
	 * Converts a double into a packed decimal.  Typically in COBOL a packed decimal
	 * is written like S9(3)V99 which means the largest number is 999.99 but the number
	 * can range like 099.99 and 009.90 -- note the zeros for padding.  This method handles
	 * all the oddities of COBOL land with regard to packing the decimal.
	 * 
	 * Note: scale can be less than zero. This means that the assumed decimal point 
	 * is -scale digits to the right of the LSD. For example, if the data in the 
	 * input file is 123 and the scale is –2, then the value thus represented is 12300.  
	 * 
	 * @param val the value to pack
	 * @param byteLength the expected output byte[] length
	 * @param scale the number of digits after the implied decimal
	 * @param isSigned - if this double is signed
	 * @return byte[] reprensentation of a packed decimal
	 * @throws Sock7Exception
	 */
	public static byte[] convertDoubleToCOMP3(double val, int byteLength, int scale, boolean isSigned) throws Sock7Exception {

		if (!isWithinTolerance(val)) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		char sign;
		if (!isSigned) {
			sign = SIGN_UNSIGNED;
		} else {
			sign = (val < 0) ? SIGN_NEG : SIGN_POS;
		}

		return packDataIntoBytes(normalizeJavaDataIntoCOMP3ByteString(formatDoubleValue(val), byteLength, scale, sign));
	}

	/**
	  * Converts an int into a numeric.  Typically in COBOL a NUMERIC
	  * is written like S9(3) which means the largest number is 999 but the number
	  * can range like 099 and 009 -- note the zeros for padding.  This method handles
	  * all the oddities of COBOL land with regard to packing the number.
	  * 
	  * Note: scale can be less than zero. This means that the assumed decimal point 
	  * is -scale digits to the right of the LSD. For example, if the data in the 
	  * input file is 123 and the scale is –2, then the value thus represented is 12300. 
	  * 
	  * @param val the value to pack 
	  * @param byteLength the expected output byte[] length
	  * @param scale the number of digits after the implied decimal
	  * @return byte[] reprensentation of a packed decimal
	  * @throws Sock7Exception
	  */
	public static byte[] convertIntToNumeric(int val, int byteLength, int scale, boolean isSigned) throws Sock7Exception {

		if (!isWithinTolerance(val)) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		char sign;
		if (!isSigned) {
			sign = SIGN_UNSIGNED;
		} else {
			sign = (val < 0) ? SIGN_NEG : SIGN_POS;
		}

		return packDataIntoBytes(normalizeJavaDataIntoNumericByteString(formatIntValue(val), byteLength, scale, sign));
	}

	/**
	 * Converts a double into a signed numeric.  Typically in COBOL a NUMERIC
	 * is written like S9(3)V99 which means the largest number is 999.99 but the number
	 * can range like 099.99 and 009.90 -- note the zeros for padding.  This method handles
	 * all the oddities of COBOL land with regard to packing the decimal.
	 * 
	 * Note: scale can be less than zero. This means that the assumed decimal point 
	 * is -scale digits to the right of the LSD. For example, if the data in the 
	 * input file is 123 and the scale is –2, then the value thus represented is 12300.  
	 * 
	 * @param val the value to sign
	 * @param byteLength the expected output byte[] length
	 * @param scale the number of digits after the implied decimal
	 * @param isSigned - if this double is signed
	 * @return byte[] reprensentation of a packed decimal
	 * @throws Sock7Exception
	 */
	public static byte[] convertDoubleToNumeric(double val, int byteLength, int scale, boolean isSigned) throws Sock7Exception {

		if (!isWithinTolerance(val)) {
			throw new NumberSizeException(MainFrameGlobals.COBOLConversionUtils_NumberSizeMessage);
		}

		char sign;
		if (!isSigned) {
			sign = SIGN_UNSIGNED;
		} else {
			sign = (val < 0) ? SIGN_NEG : SIGN_POS;
		}

		return packDataIntoBytes(normalizeJavaDataIntoNumericByteString(formatDoubleValue(val), byteLength, scale, sign));
	}

	// -------------- Private Accessory Methods

	/**
	 * Trivial accessory method which determines the precision of a
	 * packed decimal number. (How many digits the number will be)
	 * 
	 * @param arrayLength - the length of the byte array containing the data
	 */
	protected static int determinePrecision(int arrayLength) {
		
		return (arrayLength * 2) - 1;
	}

	/**
	 * Uses a mask to determine if the sign is negative.
	 * Positive and unsigned return the same (false).
	 * 
	 * Precondition: the signbit is the high nybble in the
	 * last byte (COMP-3)
	 * 
	 * @param signbit the byte which holds the sign
	 * @throws Sock7Exception
	 */

	protected static boolean isNegativeHighNybbleSignBit(byte signbit) throws Sock7Exception {

		int sign = digOutHighNybbleValue(signbit);
		
		if(!checkSign(sign)) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_SignBit);
		}
		
		return sign == HEX_NEG;
	}

	/**
	 * Uses a mask to determine if the sign is negative.
	 * Positive and unsigned return the same (false).
	 * 
	 * Precondition: the signbit is the low nybble in the
	 * last byte (NUMERIC)
	 * 
	 * @param signbit the byte which holds the sign
	 * @throws Sock7Exception
	 */
	private static boolean isNegativeLowNybbleSignBit(byte signbit) throws Sock7Exception {
		
		int sign = digOutLowNybbleValue(signbit);
		
		if(!checkSign(sign)) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_SignBit + ": " + sign);
		}
		
		return (sign == HEX_NEG);
	}

	/**
	 * Trivial accessory method which determines by what number
	 * we multiply something (1 or -1) to set the sign on a Java
	 * int/long/double.
	 * 
	 * Precondition: the signbit is the high nybble (COMP-3)
	 * 
	 * @param signbit byte which holds the sign
	 * @return 1 or -1
	 * @throws Sock7Exception
	 */
	private static int digOutSignMultiplierHighNybble(byte signbit) throws Sock7Exception {

		return (isNegativeHighNybbleSignBit(signbit)) ? -1 : 1;
	}

	/**
	 * Trivial accessory method which determines by what number
	 * we multiply something (1 or -1) to set the sign on a Java
	 * int/long/double.
	 * 
	 * Precondition: the signbit is the low nybble (NUMERIC)
	 * 
	 * @param signbit byte which holds the sign
	 * @return 1 or -1
	 * @throws Sock7Exception
	 */
	private static int digOutSignMultiplierLowNybble(byte signbit) throws Sock7Exception {

		return (isNegativeLowNybbleSignBit(signbit)) ? -1 : 1;
	}

	/**
	 * Digs out the value packed in the upper nybble of
	 * a packed decimal
	 * 
	 * @param b the byte
	 * @return and int value between 0-9
	 */
	private static int digOutHighNybbleValue(byte b) {
		
		return (b & HIGH_NYBBLE_MASK) >>> 4;
	}

	/**
	 * Digs out the value packed in the lower nybble of
	 * a packed decimal
	 * 
	 * @param b the byte
	 * @return and int value between 0-9
	 */
	private static int digOutLowNybbleValue(byte b) {
		
		return (b & LOW_NYBBLE_MASK);
	}

	/** 
	 * Unpacks a numeric (signed/un) field checking the upper nybble to make sure
	 * it contains a full bit mask and that the byte value is within the limits
	 * of what a numeric can hold.
	 *
	 * @param b
	 * @return int
	 * @throws Sock7Exception
	 */
	private static int unpackNumericByte(byte b) throws Sock7Exception {

		if (b > NUMERIC_BYTE_MAX_VALUE)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_ByteLengthTooLarge);
		
		int[] nbyte = bustByteIntoNybbles(b);
		
		// Nulled values contain 0 in both nybbles
		if(nbyte[0] == 0 & nbyte[1] == 0)
			return nbyte[1];

		if (nbyte[0] != 0xF)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_NumericUpperNybbleLow + " , " + nbyte[0] + ":" + nbyte[1]);
		
		// According to the COBOL standards, the upper nybble of a NUMERIC field's byte can only contain a F (1111)
		// for the non-sign-bit-bytes.  The sign-bit can contain either an 0xF (unsigned), 0xC or 0xD (for signed numerics),
		// or possibly a 0 if the field is "NULLED."

		return nbyte[1];
	}
	
	/**
	 * Unpacks a COMP3 byte into an int[] checking to make sure the bytes are within our
	 * tolerable limits.  Note: You can't pass the sign-bit containing byte into this method
	 * or it will puke.
	 * 
	 * @param b
	 * @return int[]
	 * @throws Sock7Exception
	 */
	private static int[] unpackCOMP3Byte(byte b) throws Sock7Exception {
		
		if (b > PACKED_BYTE_MAX_VALUE) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_ByteLengthTooLarge);
		}
		
		int [] cbyte = bustByteIntoNybbles(b);
		
		//TODO check this
		if (cbyte[0] > 9 || cbyte[1] > 9)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_COMP3_Value + ", " + cbyte[0] + ":" + cbyte[1]);
		
		return cbyte;
	}
	
	/**
	 * Busts a byte into an int[] based on the nybbles.  The int[] contains exactly two elements
	 * with the 0 element containing the "high" nybble value and the 1 element containing the
	 * "low" nybble value.
	 * 
	 * @param b - the byte
	 * @return int[] containing the busted-up byte
	 */
	private static int[] bustByteIntoNybbles(byte b) {
		
		int[] ubyte = new int[2];
		
		ubyte[0] = digOutHighNybbleValue(b);
		ubyte[1] = digOutLowNybbleValue(b);
		
		return ubyte;
	}
	
	/**
	 * Checks to see if a sign bit holds a potentially valid value.
	 * 
	 * TODO What about "NULLED" fields?
	 * 
	 * @param signbit - the dug out sign bit
	 * @return true/false
	 */
	private static boolean checkSign(int signbit) {
		
		return (signbit == 0xC || signbit == 0xD || signbit == 0xF || signbit == 0);
	}
	
	/**
	 * Returns true if and only if the conversion value is within
	 * our tolerance of less than DOUBLE_MAX_TRANSLATION_VALUE and
	 * greater than DOUBLE_MIN_TRANSLATION_VALUE
	 * 
	 * @param d double we are converting
	 * @return boolean
	 */
	private static boolean isWithinTolerance(double d) {

		return (DOUBLE_MIN_TRANSLATION_VALUE <= d && d <= DOUBLE_MAX_TRANSLATION_VALUE);
	}	

	/**
	 * Formats an int into non-scientific notation and
	 * strips out any commas or other junk -- only does this
	 * if the input value is greater than the 
	 * <code>DOUBLE_THRESHOLD</code>
	 * 
	 * @param i the input int
	 * @return String
	 */
	private static String formatIntValue(int i) {

		if (i > MainFrameGlobals.DOUBLE_THRESHOLD) {
			decimalformat.applyPattern(MainFrameGlobals.INT_FORMAT);
			return decimalformat.format(i);
		} else {
			return String.valueOf(i);
		}
	}
	/**
	 * Formats a double into non-scientific notation and
	 * strips out any commas or other junk -- only does this
	 * if the input value is greater than the 
	 * <code>DOUBLE_THRESHOLD</code>
	 *  
	 * For high precision numbers, we need to format to strip out SI
	 * 
	 * @param d the input double
	 * @return String
	 */
	private static String formatDoubleValue(double d) {

		if (d > MainFrameGlobals.DOUBLE_THRESHOLD) {
			decimalformat.applyPattern(MainFrameGlobals.DOUBLE_FORMAT);
			return decimalformat.format(d);
		} else {
			return String.valueOf(d);
		}
	}
	
	/**
	 * Converts a normalized String into a packed byte[] -- This actually
	 * creates the packed decimal.
	 * 
	 * @param val - normalized String
	 * @return byte[] reprensentation of a packed decimal
	 */
	private static byte[] packDataIntoBytes(String val) {

		byte[] bytes = new byte[val.length() / 2];
		int k = 0;
		for (int i = 0; i < val.length(); i += 2) {
			/**
			 * You take the 'high' value and << 4, then you
			 * take the 'low' value and << 128.  Unless we've
			 * hit the last 4 bits which we need to get the hex value
			 * and then process like we did a normal low value.
			 * ('char' - 55)
			 * 
			 * I *could* do this manually, but the below way is easier
			 * and runs just as fast "on my box."
			 */
			bytes[k++] = (byte) Integer.parseInt(val.substring(i, i + 2), 16);
		}
		return bytes;
	}

	/**
	 * Debugging function which breaks up a normalized bit-pattern 
	 * string into byte increments by adding a space every two chars.
	 * 
	 * @param val
	 * @return String
	 */
	private static String displayInBytePattern(String val) {
		
		StringBuffer sb = new StringBuffer();
		
		for (int i = 0; i < val.length(); i += 2) {
			sb.append(val.substring(i, i + 2));
			sb.append(" ");
		}

		return sb.toString();

	}	

	// -------------- Private Conversion Methods

	/**
	 * Convert a range of packed (COMP-3) nybbles to a double. Each byte up until the sign bit
	 * containing byte gets checked to make sure the nybbles contain valid values.
	 * 
	 * @deprecated - use packedNybblesToDouble instead.  Functionally, this method is still
	 * safe to use.
	 * @param buffer - the byte[] containing the packed decimal
	 * @return int amount of the packed data
	 * @throws Sock7Exception if the bytes contain values too large
	 */
	private static final int packedNybblesToInt(byte[] buffer) throws Sock7Exception {

		int value = 0;

		for (int i = 0; i < buffer.length - 1; i++) {

			int[] cbyte = unpackCOMP3Byte(buffer[i]);
			// We multiply by 10 to advance the number to the next order of magnitude
			// in terms of one, tens, hundreds, thousands, etc
			value = value * 10 + cbyte[0];
			value = value * 10 + cbyte[1];
		}
		
		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.
		value = value * 10 + digOutHighNybbleValue(buffer[buffer.length - 1]);

		return value;
	}

	/**
	 * Convert a range of packed (COMP-3) nybbles to a double. Each byte up until the sign bit
	 * containing byte gets checked to make sure the nybbles contain valid values. 
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @return double amount of the packed data
	 * @throws Sock7Exception if the bytes contain values too large
	 */
	private static final double packedNybblesToDouble(byte[] buffer) throws Sock7Exception {

		double value = 0;

		for (int i = 0; i < buffer.length - 1; i++) {

			int[] cbyte = unpackCOMP3Byte(buffer[i]);
			// We multiply by 10 to advance the number to the next order of magnitude
			// in terms of one, tens, hundreds, thousands, etc
			value = value * 10 + cbyte[0];
			value = value * 10 + cbyte[1];
		}
		
		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.
		value = value * 10 + digOutHighNybbleValue(buffer[buffer.length - 1]);

		return value;
	}


	/**
	 * Convert a range of packed nybbles (up to 9 digits without overflow) to an
	 * String. 
	 *  
	 * @param buffer - the byte[] containing the packed decimal
	 * @return String containing the unpacked data
	 * @throws Sock7Exception if the bytes contain values too large
	 */
	private static final String packedNybblesToString(byte[] buffer) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();

		for (int i = 0; i < buffer.length - 1; i++) {

			int[] cbyte = unpackCOMP3Byte(buffer[i]);
			// We multiply by 10 to advance the number to the next order of magnitude
			// in terms of one, tens, hundreds, thousands, etc
			sb.append(cbyte[0]);
			sb.append(cbyte[1]);
		}
		
		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.
		sb.append(digOutHighNybbleValue(buffer[buffer.length - 1]));

		return sb.toString();
	}

	/**
	 * Convert a range of signed nybbles to a String. Each byte up until the sign bit
	 * containing byte gets checked to make sure the upper nybble contains a full set of bits. 
	 *
	 * @param buffer - the byte[] containing the packed decimal
	 * @param startNybble - the nybbble we start at
	 * @param numberOfNybbles - the number of nybbles to process
	 * @return String containing the unpacked data
	 * @throws Sock7Exception
	 */
	private static final String numericNybblesToString(byte[] buffer) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();
		
		for (int i = 0; i < buffer.length - 1; i++) {
			sb.append(unpackNumericByte(buffer[i]));
		}
		
		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.	
		sb.append(digOutLowNybbleValue(buffer[buffer.length - 1]));

		return sb.toString();
	}

	/**
	 * Convert a range of signed nybbles to a int. Each byte up until the sign bit
	 * containing byte gets checked to make sure the upper nybble contains a full set of bits. 
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @param startNybble - the nybbble we start at
	 * @param numberOfNybbles - the number of nybbles to process
	 * @return int amount of the packed data
	 * @throws Sock7Exception
	 */
	private static final int numericNybblesToInt(byte[] buffer) throws Sock7Exception {

		int value = 0;
		
		for (int i = 0; i < buffer.length - 1; i++) {
			value = value * 10 + unpackNumericByte(buffer[i]);
		}

		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.		
		value = value * 10 + digOutLowNybbleValue(buffer[buffer.length]);

		return value;
	}

	/**
	 * Convert a range of signed nybbles to a long. Each byte up until the sign bit
	 * containing byte gets checked to make sure the upper nybble contains a full set of bits. 
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @param startNybble - the nybbble we start at
	 * @param numberOfNybbles - the number of nybbles to process
	 * @return long amount of the packed data
	 * @throws Sock7Exception
	 */
	private static final long numericNybblesToLong(byte[] buffer) throws Sock7Exception {

		long value = 0;
		
		for (int i = 0; i < buffer.length - 1; i++) {
			value = value * 10 + unpackNumericByte(buffer[i]);
		}
		
		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.
		value = value * 10 + digOutLowNybbleValue(buffer[buffer.length]);
		
		return value;
	}

	/**
	 * Convert a range of signed nybbles to a double. Each byte up until the sign bit
	 * containing byte gets checked to make sure the upper nybble contains a full set of bits. 
	 * 
	 * @param buffer - the byte[] containing the packed decimal
	 * @return double amount of the packed data
	 * @throws Sock7Exception
	 */
	private static final double numericNybblesToDouble(byte[] buffer) throws Sock7Exception  {

		double value = 0;

		for (int i = 0; i < buffer.length - 1; i++) {
			value = value * 10 + unpackNumericByte(buffer[i]);
		}

		// We skip this value in the loop b/c the sign-bit will throw off the check.
		// The signbit is checked for validity elsewhere.
		value = value * 10 + digOutLowNybbleValue(buffer[buffer.length - 1]);
		
		return value;
	}

	/**
	 * Converts an input numeric String into the proper form for COBOL COMP-3.  That is, we
	 * append the sign and do some length checking and adding zeros when necessary (as well as
	 * stripping the period out of a double).
	 * 
	 * Note: scale can be less than zero. This means that the assumed decimal point 
	 * is -scale digits to the right of the LSD. For example, if the data in the 
	 * input file is 123 and the scale is –2, then the value thus represented is 12300. 
	 * 
	 * @param value the numeric value just String.valueOf(...)
	 * @param byteLength length of bytes the output array must be
	 * @param scale - the scale.  We can have negative scales, btw. It's retarded but COBOL guys use it.
	 * @param sign the sign
	 * @return normalized String of the value
	 * @throws Sock7Exception
	 */
	private static String normalizeJavaDataIntoCOMP3ByteString(String value, int byteLength, int scale, char sign) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();
		sb.append(value);

		// Find out if we have a decimal
		int decPos = value.indexOf(".");

		//Remove the negative sign :^)
		if (sb.charAt(0) == '-')
			sb.deleteCharAt(0);

		if (scale < 0)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_InvalidScale);

		if (decPos > -1 & scale <= 0)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_InvalidScale);

		if (decPos != -1) {
			// Figure out by how much we need to move the decimal position
			int trailingZeros = scale - sb.toString().substring(sb.toString().indexOf(".") + 1).length();
			sb.deleteCharAt(decPos);

			for (int i = 0; i < trailingZeros; i++)
				sb.append("0");
		}

		sb.append(Character.toUpperCase(sign));
		// Figure out how much we need to pad this number to make it the right byte length.
		int zeroFill = (byteLength * 2 - 1) - sb.length();
		if (zeroFill < 0) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_ByteLengthTooSmall);
		}

		for (int i = 0; i < zeroFill; i++)
			sb.insert(0, "0");

		// Insert zero to make string even lengthed	
		if (sb.toString().length() % 2 != 0)
			sb.insert(0, "0");

		if (log.isEnabledFor(Level.DEBUG)) {
			log.debug("COBOLConversionUtil.normalizeJavaDataIntoCOMP3ByteString("
					+ value + ", " 	+ byteLength + ", "
					+ scale + ", " + sign + ") output: "
					+ displayInBytePattern(sb.toString()));
		}

		return sb.toString();
	}

	/**
	 * Converts an input numeric String into the proper form for COBOL NUMERIC.  That is, we
	 * append the sign and do some length checking and adding zeros when necessary (as well as
	 * stripping the period out of a double).
	 * 
	 * Note: scale can be less than zero. This means that the assumed decimal point 
	 * is -scale digits to the right of the LSD. For example, if the data in the 
	 * input file is 123 and the scale is –2, then the value thus represented is 12300. 
	 * 
	 * @param value the numeric value just String.valueOf(...)
	 * @param byteLength length of bytes the output array must be
	 * @param scale - the scale.  We can have negative scales, btw. It's retarded but COBOL guys use it.
	 * @param sign the sign
	 * @return normalized String of the value
	 * @throws Sock7Exception
	 */
	private static String normalizeJavaDataIntoNumericByteString(String value, int byteLength, int scale, char sign) throws Sock7Exception {

		StringBuffer sb = new StringBuffer();
		int precedingZeros = 0;

		StringBuffer tmp = new StringBuffer();
		tmp.append(value);

		// Remove the - sign
		if (tmp.charAt(0) == '-')
			tmp.deleteCharAt(0);

		for (int i = 0; i < tmp.length() - 1; i++) {
			if (tmp.charAt(i) != '.') {
				sb.append('F');
				sb.append(tmp.charAt(i));
			}
		}

		// Stick in the sign
		sb.append(sign);
		sb.append(tmp.charAt(tmp.length() - 1));

		// Find out if we have a decimal
		int decPos = value.indexOf(".");

		if (scale < 0)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_InvalidScale);

		if (decPos > -1 & scale <= 0)
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_InvalidScale);

		if (decPos != -1) {
			precedingZeros = scale - sb.toString().substring(sb.toString().indexOf(".") + 1).length();
		}

		int zeroFill = (byteLength * 2) - sb.length();
		if (zeroFill < 0) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_ByteLengthTooSmall);
		}

		for (int i = 0; i < zeroFill; i++)
			sb.insert(0, "F0");

		if (log.isEnabledFor(Level.DEBUG)) {
			log.debug(
				"COBOLConversionUtil.normalizeJavaDataIntoNumericByteString("
					+ value + ", " + byteLength + ", "
					+ scale + ", " + sign
					+ ") output: " + displayInBytePattern(sb.toString())
			);
		}

		return sb.toString();
	}
}